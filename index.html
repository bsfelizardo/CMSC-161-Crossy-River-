<!doctype html>
<html>
<head>
  <title>WebGL Demo</title>
</head>

<body>
  <canvas id="output" width="1280" height="720"></canvas>

  <script src="./utils/gl-matrix.js"></script>
  
  <!-- VERTEX SHADER -->
  <script id="vertex-shader" type="notjs">#version 300 es
    in vec4 a_position;
    in float a_point_size;
    
    // For view, model, and projection transformations
    uniform mat4 u_model_matrix;
    uniform mat4 u_view_matrix;
    uniform mat4 u_projection_matrix;

    void main() {
      // Apply the transformations to the object to be rendered
      gl_Position = u_view_matrix * u_model_matrix * u_projection_matrix * a_position;
    }
  </script>

  <!-- FRAGMENT SHADER -->
  <script id="fragment-shader" type="notjs">#version 300 es
    precision mediump float;

    uniform vec4 u_color;
    out vec4 outColor;

    void main(void) {
      //outColor = vec4(1, 0, 0, 1); //red
    
      outColor = u_color;
    }
  </script>

  <!-- Function for creating and compiling shader programs -->
  <script>
    function createShader (gl, type, sourceCode) {
      // Compiles either a shader of type gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
      var shader = gl.createShader( type );
      gl.shaderSource( shader, sourceCode );
      gl.compileShader( shader );

      if ( !gl.getShaderParameter(shader, gl.COMPILE_STATUS) ) {
        var info = gl.getShaderInfoLog( shader );
        throw 'Could not compile WebGL program. \n\n' + info;
      }
      return shader;
    }
  </script>
  
  <!-- Main function contains: 
    1) declaration of WebGL context
    2) function calls to initialize the shader programs
    3) declaration and binding of buffer object
    4) function calls to perform transformations before drawing
    5) draw/redraw functions
  -->

  <script src="assets/land.js"></script>
  <script src="assets/character.js"></script>
  <script src="assets/character1.js"></script>
  <script src="assets/character2.js"></script>
  <script src="assets/character3.js"></script>
  <script src="assets/character4.js"></script>
  <script src="assets/character5.js"></script>
  <script src="assets/character6.js"></script>
  <script src="assets/character7.js"></script>
  <script src="assets/raft.js"></script>
  <script> 
    function main() {
      const canvas = document.querySelector('#output');
      if(!canvas){
        console.log("Canvas element with specified ID ('output') cannot be found.");
      }

      //Setting up the WebGL Context
      const gl = canvas.getContext('webgl2');
      const vertexShaderSource = document.querySelector('#vertex-shader').text;
      const fragmentShaderSource = document.querySelector('#fragment-shader').text;
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      

      //Creation and initialization of GL program 
      var program = gl.createProgram();

      // Attach pre-existing shaders
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      gl.linkProgram(program);

      if ( !gl.getProgramParameter( program, gl.LINK_STATUS) ) {
        var info = gl.getProgramInfoLog(program);
        throw 'Could not compile WebGL program. \n\n' + info;
      }

      // set the program created earlier
      gl.useProgram(program);

      // Declaration of pointers to the attributes
      const aPositionPointer = gl.getAttribLocation(program, 'a_position');
      const aPointSizePointer = gl.getAttribLocation(program, 'a_point_size');

      var colorLocation = gl.getUniformLocation(program, "u_color");

      const uModelMatrixPointer = gl.getUniformLocation(program, 'u_model_matrix');
      const uViewMatrixPointer = gl.getUniformLocation(program, 'u_view_matrix');
      const uProjectionMatrixPointer = gl.getUniformLocation(program, 'u_projection_matrix');
      
      // load vertex data to gpu
      const square1Buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, square1Buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(upper_land), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      const lower_land_buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, lower_land_buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lower_land), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      //create a buffer object
      var shapeBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER,shapeBuffer);
      gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(line_vertices),gl.STATIC_DRAW);

      // setup model matrix;
      modelTranslate = [0,0,0,0]
      const modelMatrix = glMatrix.mat4.create();
      glMatrix.mat4.translate(modelMatrix, modelMatrix, modelTranslate);

      viewPoint = [0.05,0.05,0.05,1]
      centerPoint = [0,0,0,1]
      upVector = [0,1,0,0]

      // setup view matrix
      const viewMatrix = glMatrix.mat4.create();
      glMatrix.mat4.lookAt(
        viewMatrix, 
        viewPoint,
        centerPoint,
        upVector
      );
      // glMatrix.mat4.lookAt(viewMatrix,[0.3,0.3,-0.5,1],[0,0,0,1],[1,0,0,0]);
      

      // setup projection matrix
      const projectionMatrix = glMatrix.mat4.create();
      // parameters to set parallel projection
      var left = -1;
      var right = 1;
      var bottom = -1;
      var top = 1;
      var near = -1;
      var far = 1;
      glMatrix.mat4.ortho(projectionMatrix, left, right, bottom, top, near, far);

     

      // function to draw the scene from the user inputs
      function drawScene() {
        // enable attrib array
        gl.enableVertexAttribArray(aPositionPointer);
        
        // load uniforms (only done once; since values are same for all vertices)
        gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));
        gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
        gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));
          
        // clear the screen
        gl.clearColor(0.5137, 0.8431, 0.9333, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);

        //same for the other object to be drawn
        gl.bindBuffer(gl.ARRAY_BUFFER, square1Buffer);
        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
        gl.uniform4f(colorLocation,0.0,1.0,0.0,1.0);
        gl.drawArrays(gl.TRIANGLES, 0, upper_land.length/4);

        gl.bindBuffer(gl.ARRAY_BUFFER, lower_land_buffer);
        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
        gl.uniform4f(colorLocation,0.0,1.0,0.0,1.0);
        gl.drawArrays(gl.TRIANGLES, 0, lower_land.length/4);

        gl.disable(gl.DEPTH_TEST);
        gl.bindBuffer(gl.ARRAY_BUFFER, shapeBuffer);
        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
        gl.uniform4f(colorLocation,0.5215,0.3686,0.2588,1.0);
        gl.drawArrays(gl.TRIANGLES,74,6);

        gl.uniform4f(colorLocation,0,0,0,1.0); //black outline
        // gl.vertexAttrib1f(aPointSizePointer, 5.0);
        gl.drawArrays(gl.LINE_LOOP,0,4); //raft perimeter
        gl.drawArrays(gl.LINE_LOOP,24,50); //logs/rows
        gl.drawArrays(gl.LINES,4,20); //line texture
        
        // gl.drawArrays(gl.POINTS,80,6); 
        
        
        // character [start]
        start_to_river7(
        {destination:"start",
          origin: "start",
          gl,
          aPositionPointer,
          colorLocation,
        })

        start_to_river6(
        {destination:"start",
          origin: "start",
          gl,
          aPositionPointer,
          colorLocation,
        })

        start_to_river5(
        {destination:"start",
          origin: "start",
          gl,
          aPositionPointer,
          colorLocation,
        })

        start_to_river(
          {destination:"start",
            origin: "start",
            gl,
            aPositionPointer,
            colorLocation,
          })

        start_to_river1(
          {destination:"start",
            origin: "start",
            gl,
            aPositionPointer,
            colorLocation,
          })

        start_to_river2(
        {destination:"start",
          origin: "start",
          gl,
          aPositionPointer,
          colorLocation,
        })

        start_to_river3(
        {destination:"start",
          origin: "start",
          gl,
          aPositionPointer,
          colorLocation,
        })

        start_to_river4(
        {destination:"start",
          origin: "start",
          gl,
          aPositionPointer,
          colorLocation,
        })







        
        // character [end]

        gl.enable(gl.DEPTH_TEST);

        const x_axis_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, x_axis_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          1.0, 0, 0, 1,
          -1.0, 0, 0, 1,
        ]), gl.STATIC_DRAW);
        // gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.uniform4fv(colorLocation, [1, 0, 0, 1]);
        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINES, 0, 8);

        const y_axis_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, y_axis_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          0.0, 1, 0, 1,
          0.0, -1, 0, 1,
        ]), gl.STATIC_DRAW);
        // gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.uniform4fv(colorLocation, [0, 1, 0, 1]);
        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINES, 0, 8);

        const z_axis_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, z_axis_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          0.0, 0, 1, 1,
          0.0, 0, -1, 1,
        ]), gl.STATIC_DRAW);
        // gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.uniform4fv(colorLocation, [0, 0, 1, 1]);
        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINES, 0, 8);
      }

      // initial render
      drawScene();
    }
    // call the main program
    main();
  </script>
</body>
</html>